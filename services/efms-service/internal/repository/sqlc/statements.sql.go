// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: statements.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createStatement = `-- name: CreateStatement :one
INSERT INTO statements (
    user_id,
    upload_id,
    description,
    statement_date,
    bank_name,
    status,
    processing_progress,
    updated_by -- initially same as user_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $1
) RETURNING submission_id, user_id, upload_id, description, statement_date, bank_name, status, processing_progress, error_message, insights_available, created_at, updated_at, updated_by
`

type CreateStatementParams struct {
	UserID             uuid.UUID       `json:"user_id"`
	UploadID           uuid.UUID       `json:"upload_id"`
	Description        sql.NullString  `json:"description"`
	StatementDate      sql.NullTime    `json:"statement_date"`
	BankName           sql.NullString  `json:"bank_name"`
	Status             StatementStatus `json:"status"`
	ProcessingProgress sql.NullInt32   `json:"processing_progress"`
}

func (q *Queries) CreateStatement(ctx context.Context, arg CreateStatementParams) (Statement, error) {
	row := q.queryRow(ctx, q.createStatementStmt, createStatement,
		arg.UserID,
		arg.UploadID,
		arg.Description,
		arg.StatementDate,
		arg.BankName,
		arg.Status,
		arg.ProcessingProgress,
	)
	var i Statement
	err := row.Scan(
		&i.SubmissionID,
		&i.UserID,
		&i.UploadID,
		&i.Description,
		&i.StatementDate,
		&i.BankName,
		&i.Status,
		&i.ProcessingProgress,
		&i.ErrorMessage,
		&i.InsightsAvailable,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const deleteStatementByIDAndUser = `-- name: DeleteStatementByIDAndUser :exec
DELETE FROM statements
WHERE submission_id = $1 AND user_id = $2
`

type DeleteStatementByIDAndUserParams struct {
	SubmissionID uuid.UUID `json:"submission_id"`
	UserID       uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteStatementByIDAndUser(ctx context.Context, arg DeleteStatementByIDAndUserParams) error {
	_, err := q.exec(ctx, q.deleteStatementByIDAndUserStmt, deleteStatementByIDAndUser, arg.SubmissionID, arg.UserID)
	return err
}

const getStatementByIDAndUser = `-- name: GetStatementByIDAndUser :one
SELECT submission_id, user_id, upload_id, description, statement_date, bank_name, status, processing_progress, error_message, insights_available, created_at, updated_at, updated_by FROM statements
WHERE submission_id = $1 AND user_id = $2
`

type GetStatementByIDAndUserParams struct {
	SubmissionID uuid.UUID `json:"submission_id"`
	UserID       uuid.UUID `json:"user_id"`
}

func (q *Queries) GetStatementByIDAndUser(ctx context.Context, arg GetStatementByIDAndUserParams) (Statement, error) {
	row := q.queryRow(ctx, q.getStatementByIDAndUserStmt, getStatementByIDAndUser, arg.SubmissionID, arg.UserID)
	var i Statement
	err := row.Scan(
		&i.SubmissionID,
		&i.UserID,
		&i.UploadID,
		&i.Description,
		&i.StatementDate,
		&i.BankName,
		&i.Status,
		&i.ProcessingProgress,
		&i.ErrorMessage,
		&i.InsightsAvailable,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const getStatementStatusByIDAndUser = `-- name: GetStatementStatusByIDAndUser :one
SELECT submission_id, status, processing_progress, error_message, insights_available FROM statements
WHERE submission_id = $1 AND user_id = $2
`

type GetStatementStatusByIDAndUserParams struct {
	SubmissionID uuid.UUID `json:"submission_id"`
	UserID       uuid.UUID `json:"user_id"`
}

type GetStatementStatusByIDAndUserRow struct {
	SubmissionID       uuid.UUID       `json:"submission_id"`
	Status             StatementStatus `json:"status"`
	ProcessingProgress sql.NullInt32   `json:"processing_progress"`
	ErrorMessage       sql.NullString  `json:"error_message"`
	InsightsAvailable  bool            `json:"insights_available"`
}

func (q *Queries) GetStatementStatusByIDAndUser(ctx context.Context, arg GetStatementStatusByIDAndUserParams) (GetStatementStatusByIDAndUserRow, error) {
	row := q.queryRow(ctx, q.getStatementStatusByIDAndUserStmt, getStatementStatusByIDAndUser, arg.SubmissionID, arg.UserID)
	var i GetStatementStatusByIDAndUserRow
	err := row.Scan(
		&i.SubmissionID,
		&i.Status,
		&i.ProcessingProgress,
		&i.ErrorMessage,
		&i.InsightsAvailable,
	)
	return i, err
}

const listStatementsByUser = `-- name: ListStatementsByUser :many
SELECT submission_id, statement_date, bank_name, status, created_at AS upload_date, insights_available
FROM statements
WHERE user_id = $1
AND ($2::varchar IS NULL OR status = $2::varchar)
AND ($3::date IS NULL OR statement_date >= $3::date)
AND ($4::date IS NULL OR statement_date <= $4::date)
ORDER BY created_at DESC
LIMIT $5 OFFSET $6
`

type ListStatementsByUserParams struct {
	UserID  uuid.UUID `json:"user_id"`
	Column2 string    `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListStatementsByUserRow struct {
	SubmissionID      uuid.UUID       `json:"submission_id"`
	StatementDate     sql.NullTime    `json:"statement_date"`
	BankName          sql.NullString  `json:"bank_name"`
	Status            StatementStatus `json:"status"`
	UploadDate        time.Time       `json:"upload_date"`
	InsightsAvailable bool            `json:"insights_available"`
}

// TODO: Add tag filtering once statement_tags queries are in place and we decide on join strategy
func (q *Queries) ListStatementsByUser(ctx context.Context, arg ListStatementsByUserParams) ([]ListStatementsByUserRow, error) {
	rows, err := q.query(ctx, q.listStatementsByUserStmt, listStatementsByUser,
		arg.UserID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStatementsByUserRow{}
	for rows.Next() {
		var i ListStatementsByUserRow
		if err := rows.Scan(
			&i.SubmissionID,
			&i.StatementDate,
			&i.BankName,
			&i.Status,
			&i.UploadDate,
			&i.InsightsAvailable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStatementMetadataByIDAndUser = `-- name: UpdateStatementMetadataByIDAndUser :one
UPDATE statements
SET
    description = COALESCE($1, description),
    statement_date = COALESCE($2, statement_date),
    bank_name = COALESCE($3, bank_name),
    updated_at = now(),
    updated_by = $4 -- user_id of the updater
WHERE submission_id = $5 AND user_id = $4 -- Ensure user owns the statement
RETURNING submission_id, user_id, upload_id, description, statement_date, bank_name, status, processing_progress, error_message, insights_available, created_at, updated_at, updated_by
`

type UpdateStatementMetadataByIDAndUserParams struct {
	Description   sql.NullString `json:"description"`
	StatementDate sql.NullTime   `json:"statement_date"`
	BankName      sql.NullString `json:"bank_name"`
	UpdaterUserID uuid.NullUUID  `json:"updater_user_id"`
	SubmissionID  uuid.UUID      `json:"submission_id"`
}

func (q *Queries) UpdateStatementMetadataByIDAndUser(ctx context.Context, arg UpdateStatementMetadataByIDAndUserParams) (Statement, error) {
	row := q.queryRow(ctx, q.updateStatementMetadataByIDAndUserStmt, updateStatementMetadataByIDAndUser,
		arg.Description,
		arg.StatementDate,
		arg.BankName,
		arg.UpdaterUserID,
		arg.SubmissionID,
	)
	var i Statement
	err := row.Scan(
		&i.SubmissionID,
		&i.UserID,
		&i.UploadID,
		&i.Description,
		&i.StatementDate,
		&i.BankName,
		&i.Status,
		&i.ProcessingProgress,
		&i.ErrorMessage,
		&i.InsightsAvailable,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const updateStatementStatusAndProgress = `-- name: UpdateStatementStatusAndProgress :one
UPDATE statements
SET
    status = $2,
    processing_progress = $3,
    error_message = $5,
    insights_available = $4,
    updated_at = now()
    -- updated_by could be a system user ID or the original user ID
WHERE submission_id = $1
RETURNING submission_id, user_id, upload_id, description, statement_date, bank_name, status, processing_progress, error_message, insights_available, created_at, updated_at, updated_by
`

type UpdateStatementStatusAndProgressParams struct {
	SubmissionID       uuid.UUID       `json:"submission_id"`
	Status             StatementStatus `json:"status"`
	ProcessingProgress sql.NullInt32   `json:"processing_progress"`
	InsightsAvailable  bool            `json:"insights_available"`
	ErrorMessage       sql.NullString  `json:"error_message"`
}

func (q *Queries) UpdateStatementStatusAndProgress(ctx context.Context, arg UpdateStatementStatusAndProgressParams) (Statement, error) {
	row := q.queryRow(ctx, q.updateStatementStatusAndProgressStmt, updateStatementStatusAndProgress,
		arg.SubmissionID,
		arg.Status,
		arg.ProcessingProgress,
		arg.InsightsAvailable,
		arg.ErrorMessage,
	)
	var i Statement
	err := row.Scan(
		&i.SubmissionID,
		&i.UserID,
		&i.UploadID,
		&i.Description,
		&i.StatementDate,
		&i.BankName,
		&i.Status,
		&i.ProcessingProgress,
		&i.ErrorMessage,
		&i.InsightsAvailable,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}
