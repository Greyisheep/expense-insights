// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: uploads.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createUpload = `-- name: CreateUpload :one
INSERT INTO uploads (
    user_id,
    file_name,
    content_type,
    size_bytes,
    status
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, user_id, file_name, content_type, status, storage_path, size_bytes, error_message, presign_expiry, created_at, updated_at
`

type CreateUploadParams struct {
	UserID      uuid.UUID     `json:"user_id"`
	FileName    string        `json:"file_name"`
	ContentType string        `json:"content_type"`
	SizeBytes   sql.NullInt64 `json:"size_bytes"`
	Status      UploadStatus  `json:"status"`
}

func (q *Queries) CreateUpload(ctx context.Context, arg CreateUploadParams) (Upload, error) {
	row := q.queryRow(ctx, q.createUploadStmt, createUpload,
		arg.UserID,
		arg.FileName,
		arg.ContentType,
		arg.SizeBytes,
		arg.Status,
	)
	var i Upload
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FileName,
		&i.ContentType,
		&i.Status,
		&i.StoragePath,
		&i.SizeBytes,
		&i.ErrorMessage,
		&i.PresignExpiry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUpload = `-- name: DeleteUpload :exec
DELETE FROM uploads
WHERE id = $1 AND user_id = $2
`

type DeleteUploadParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteUpload(ctx context.Context, arg DeleteUploadParams) error {
	_, err := q.exec(ctx, q.deleteUploadStmt, deleteUpload, arg.ID, arg.UserID)
	return err
}

const getUpload = `-- name: GetUpload :one
SELECT id, user_id, file_name, content_type, status, storage_path, size_bytes, error_message, presign_expiry, created_at, updated_at FROM uploads
WHERE id = $1 AND user_id = $2
`

type GetUploadParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) GetUpload(ctx context.Context, arg GetUploadParams) (Upload, error) {
	row := q.queryRow(ctx, q.getUploadStmt, getUpload, arg.ID, arg.UserID)
	var i Upload
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FileName,
		&i.ContentType,
		&i.Status,
		&i.StoragePath,
		&i.SizeBytes,
		&i.ErrorMessage,
		&i.PresignExpiry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUploadByFileNameAndUser = `-- name: GetUploadByFileNameAndUser :one
SELECT id, user_id, file_name, content_type, status, storage_path, size_bytes, error_message, presign_expiry, created_at, updated_at FROM uploads
WHERE file_name = $1 AND user_id = $2 AND status = 'pending'
`

type GetUploadByFileNameAndUserParams struct {
	FileName string    `json:"file_name"`
	UserID   uuid.UUID `json:"user_id"`
}

func (q *Queries) GetUploadByFileNameAndUser(ctx context.Context, arg GetUploadByFileNameAndUserParams) (Upload, error) {
	row := q.queryRow(ctx, q.getUploadByFileNameAndUserStmt, getUploadByFileNameAndUser, arg.FileName, arg.UserID)
	var i Upload
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FileName,
		&i.ContentType,
		&i.Status,
		&i.StoragePath,
		&i.SizeBytes,
		&i.ErrorMessage,
		&i.PresignExpiry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUploadStatus = `-- name: UpdateUploadStatus :one

UPDATE uploads
SET
    status = $2,
    storage_path = $3,
    updated_at = now(),
    error_message = $4
WHERE id = $1 AND user_id = $5
RETURNING id, user_id, file_name, content_type, status, storage_path, size_bytes, error_message, presign_expiry, created_at, updated_at
`

type UpdateUploadStatusParams struct {
	ID           uuid.UUID      `json:"id"`
	Status       UploadStatus   `json:"status"`
	StoragePath  sql.NullString `json:"storage_path"`
	ErrorMessage sql.NullString `json:"error_message"`
	UserID       uuid.UUID      `json:"user_id"`
}

// Or any other relevant status
func (q *Queries) UpdateUploadStatus(ctx context.Context, arg UpdateUploadStatusParams) (Upload, error) {
	row := q.queryRow(ctx, q.updateUploadStatusStmt, updateUploadStatus,
		arg.ID,
		arg.Status,
		arg.StoragePath,
		arg.ErrorMessage,
		arg.UserID,
	)
	var i Upload
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FileName,
		&i.ContentType,
		&i.Status,
		&i.StoragePath,
		&i.SizeBytes,
		&i.ErrorMessage,
		&i.PresignExpiry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
