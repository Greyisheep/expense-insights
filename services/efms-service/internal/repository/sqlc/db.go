// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package sqlc

import (
	"context"
	"database/sql"
	"fmt"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

func Prepare(ctx context.Context, db DBTX) (*Queries, error) {
	q := Queries{db: db}
	var err error
	if q.addTagToStatementStmt, err = db.PrepareContext(ctx, addTagToStatement); err != nil {
		return nil, fmt.Errorf("error preparing query AddTagToStatement: %w", err)
	}
	if q.createStatementStmt, err = db.PrepareContext(ctx, createStatement); err != nil {
		return nil, fmt.Errorf("error preparing query CreateStatement: %w", err)
	}
	if q.createUploadStmt, err = db.PrepareContext(ctx, createUpload); err != nil {
		return nil, fmt.Errorf("error preparing query CreateUpload: %w", err)
	}
	if q.deleteStatementByIDAndUserStmt, err = db.PrepareContext(ctx, deleteStatementByIDAndUser); err != nil {
		return nil, fmt.Errorf("error preparing query DeleteStatementByIDAndUser: %w", err)
	}
	if q.deleteUploadStmt, err = db.PrepareContext(ctx, deleteUpload); err != nil {
		return nil, fmt.Errorf("error preparing query DeleteUpload: %w", err)
	}
	if q.getStatementByIDAndUserStmt, err = db.PrepareContext(ctx, getStatementByIDAndUser); err != nil {
		return nil, fmt.Errorf("error preparing query GetStatementByIDAndUser: %w", err)
	}
	if q.getStatementStatusByIDAndUserStmt, err = db.PrepareContext(ctx, getStatementStatusByIDAndUser); err != nil {
		return nil, fmt.Errorf("error preparing query GetStatementStatusByIDAndUser: %w", err)
	}
	if q.getTagsForStatementStmt, err = db.PrepareContext(ctx, getTagsForStatement); err != nil {
		return nil, fmt.Errorf("error preparing query GetTagsForStatement: %w", err)
	}
	if q.getUploadStmt, err = db.PrepareContext(ctx, getUpload); err != nil {
		return nil, fmt.Errorf("error preparing query GetUpload: %w", err)
	}
	if q.getUploadByFileNameAndUserStmt, err = db.PrepareContext(ctx, getUploadByFileNameAndUser); err != nil {
		return nil, fmt.Errorf("error preparing query GetUploadByFileNameAndUser: %w", err)
	}
	if q.listStatementsByTagAndUserStmt, err = db.PrepareContext(ctx, listStatementsByTagAndUser); err != nil {
		return nil, fmt.Errorf("error preparing query ListStatementsByTagAndUser: %w", err)
	}
	if q.listStatementsByUserStmt, err = db.PrepareContext(ctx, listStatementsByUser); err != nil {
		return nil, fmt.Errorf("error preparing query ListStatementsByUser: %w", err)
	}
	if q.removeAllTagsFromStatementStmt, err = db.PrepareContext(ctx, removeAllTagsFromStatement); err != nil {
		return nil, fmt.Errorf("error preparing query RemoveAllTagsFromStatement: %w", err)
	}
	if q.removeTagFromStatementStmt, err = db.PrepareContext(ctx, removeTagFromStatement); err != nil {
		return nil, fmt.Errorf("error preparing query RemoveTagFromStatement: %w", err)
	}
	if q.updateStatementMetadataByIDAndUserStmt, err = db.PrepareContext(ctx, updateStatementMetadataByIDAndUser); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateStatementMetadataByIDAndUser: %w", err)
	}
	if q.updateStatementStatusAndProgressStmt, err = db.PrepareContext(ctx, updateStatementStatusAndProgress); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateStatementStatusAndProgress: %w", err)
	}
	if q.updateUploadStatusStmt, err = db.PrepareContext(ctx, updateUploadStatus); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateUploadStatus: %w", err)
	}
	return &q, nil
}

func (q *Queries) Close() error {
	var err error
	if q.addTagToStatementStmt != nil {
		if cerr := q.addTagToStatementStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing addTagToStatementStmt: %w", cerr)
		}
	}
	if q.createStatementStmt != nil {
		if cerr := q.createStatementStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createStatementStmt: %w", cerr)
		}
	}
	if q.createUploadStmt != nil {
		if cerr := q.createUploadStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createUploadStmt: %w", cerr)
		}
	}
	if q.deleteStatementByIDAndUserStmt != nil {
		if cerr := q.deleteStatementByIDAndUserStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing deleteStatementByIDAndUserStmt: %w", cerr)
		}
	}
	if q.deleteUploadStmt != nil {
		if cerr := q.deleteUploadStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing deleteUploadStmt: %w", cerr)
		}
	}
	if q.getStatementByIDAndUserStmt != nil {
		if cerr := q.getStatementByIDAndUserStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getStatementByIDAndUserStmt: %w", cerr)
		}
	}
	if q.getStatementStatusByIDAndUserStmt != nil {
		if cerr := q.getStatementStatusByIDAndUserStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getStatementStatusByIDAndUserStmt: %w", cerr)
		}
	}
	if q.getTagsForStatementStmt != nil {
		if cerr := q.getTagsForStatementStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getTagsForStatementStmt: %w", cerr)
		}
	}
	if q.getUploadStmt != nil {
		if cerr := q.getUploadStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getUploadStmt: %w", cerr)
		}
	}
	if q.getUploadByFileNameAndUserStmt != nil {
		if cerr := q.getUploadByFileNameAndUserStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getUploadByFileNameAndUserStmt: %w", cerr)
		}
	}
	if q.listStatementsByTagAndUserStmt != nil {
		if cerr := q.listStatementsByTagAndUserStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listStatementsByTagAndUserStmt: %w", cerr)
		}
	}
	if q.listStatementsByUserStmt != nil {
		if cerr := q.listStatementsByUserStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listStatementsByUserStmt: %w", cerr)
		}
	}
	if q.removeAllTagsFromStatementStmt != nil {
		if cerr := q.removeAllTagsFromStatementStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing removeAllTagsFromStatementStmt: %w", cerr)
		}
	}
	if q.removeTagFromStatementStmt != nil {
		if cerr := q.removeTagFromStatementStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing removeTagFromStatementStmt: %w", cerr)
		}
	}
	if q.updateStatementMetadataByIDAndUserStmt != nil {
		if cerr := q.updateStatementMetadataByIDAndUserStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateStatementMetadataByIDAndUserStmt: %w", cerr)
		}
	}
	if q.updateStatementStatusAndProgressStmt != nil {
		if cerr := q.updateStatementStatusAndProgressStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateStatementStatusAndProgressStmt: %w", cerr)
		}
	}
	if q.updateUploadStatusStmt != nil {
		if cerr := q.updateUploadStatusStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateUploadStatusStmt: %w", cerr)
		}
	}
	return err
}

func (q *Queries) exec(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (sql.Result, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).ExecContext(ctx, args...)
	case stmt != nil:
		return stmt.ExecContext(ctx, args...)
	default:
		return q.db.ExecContext(ctx, query, args...)
	}
}

func (q *Queries) query(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (*sql.Rows, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryContext(ctx, args...)
	default:
		return q.db.QueryContext(ctx, query, args...)
	}
}

func (q *Queries) queryRow(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) *sql.Row {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryRowContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryRowContext(ctx, args...)
	default:
		return q.db.QueryRowContext(ctx, query, args...)
	}
}

type Queries struct {
	db                                     DBTX
	tx                                     *sql.Tx
	addTagToStatementStmt                  *sql.Stmt
	createStatementStmt                    *sql.Stmt
	createUploadStmt                       *sql.Stmt
	deleteStatementByIDAndUserStmt         *sql.Stmt
	deleteUploadStmt                       *sql.Stmt
	getStatementByIDAndUserStmt            *sql.Stmt
	getStatementStatusByIDAndUserStmt      *sql.Stmt
	getTagsForStatementStmt                *sql.Stmt
	getUploadStmt                          *sql.Stmt
	getUploadByFileNameAndUserStmt         *sql.Stmt
	listStatementsByTagAndUserStmt         *sql.Stmt
	listStatementsByUserStmt               *sql.Stmt
	removeAllTagsFromStatementStmt         *sql.Stmt
	removeTagFromStatementStmt             *sql.Stmt
	updateStatementMetadataByIDAndUserStmt *sql.Stmt
	updateStatementStatusAndProgressStmt   *sql.Stmt
	updateUploadStatusStmt                 *sql.Stmt
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db:                                     tx,
		tx:                                     tx,
		addTagToStatementStmt:                  q.addTagToStatementStmt,
		createStatementStmt:                    q.createStatementStmt,
		createUploadStmt:                       q.createUploadStmt,
		deleteStatementByIDAndUserStmt:         q.deleteStatementByIDAndUserStmt,
		deleteUploadStmt:                       q.deleteUploadStmt,
		getStatementByIDAndUserStmt:            q.getStatementByIDAndUserStmt,
		getStatementStatusByIDAndUserStmt:      q.getStatementStatusByIDAndUserStmt,
		getTagsForStatementStmt:                q.getTagsForStatementStmt,
		getUploadStmt:                          q.getUploadStmt,
		getUploadByFileNameAndUserStmt:         q.getUploadByFileNameAndUserStmt,
		listStatementsByTagAndUserStmt:         q.listStatementsByTagAndUserStmt,
		listStatementsByUserStmt:               q.listStatementsByUserStmt,
		removeAllTagsFromStatementStmt:         q.removeAllTagsFromStatementStmt,
		removeTagFromStatementStmt:             q.removeTagFromStatementStmt,
		updateStatementMetadataByIDAndUserStmt: q.updateStatementMetadataByIDAndUserStmt,
		updateStatementStatusAndProgressStmt:   q.updateStatementStatusAndProgressStmt,
		updateUploadStatusStmt:                 q.updateUploadStatusStmt,
	}
}
